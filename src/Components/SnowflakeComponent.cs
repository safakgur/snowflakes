using System.Diagnostics;

namespace Snowflakes.Components;

/// <summary>
///     Provides a base class for components that produce parts that make up snowflakes.
/// </summary>
/// <remarks>
///     Snowflake components are used by <seealso cref="SnowflakeGenerator" />.
///     <list type="bullet">
///         <item>
///             A component instance should only be supplied to a single generator as components
///             may store state that should not be shared by different generators. An attempt to
///             add the same component to multiple generators will result in an exception.
///         </item>
///         <item>
///             The generator ensures the components are executed in the correct order, which can
///             be leveraged to write relational components.
///         </item>
///         <item>
///             The generator ensures that no component is executed concurrently, so derived
///             components do not need to implement thread safety themselves.
///         </item>
///     </list>
/// </remarks>
public abstract class SnowflakeComponent
{
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    internal const int MaxLengthInBits = 63;

    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private readonly long _mask;

    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private SnowflakeGenerator? _owner;

    /// <summary>
    ///     Initializes a new instance of the <see cref="SnowflakeComponent" /> class.
    /// </summary>
    /// <param name="lengthInBits">
    ///     <para>The number of bits this component will produce.</para>
    ///     <para>
    ///         Only the lowest <paramref name="lengthInBits" /> number of bits of the generated
    ///         values are used. Any higher bits, i.e., bits to the left, are discarded.
    ///     </para>
    /// </param>
    /// <exception cref="ArgumentOutOfRangeException">
    ///     <paramref name="lengthInBits" /> is less than 1 or greater than 63.
    /// </exception>
    public SnowflakeComponent(int lengthInBits)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(lengthInBits);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(lengthInBits, MaxLengthInBits);

        _mask = (1L << lengthInBits) - 1L;

        LengthInBits = lengthInBits;
    }

    /// <summary>Gets the number of bits this component will produce.</summary>
    public int LengthInBits { get; }

    /// <summary>Gets the last value produced by this component.</summary>
    /// <remarks>Calls to <see cref="GetValue" /> update this value.</remarks>
    public long LastValue { get; private set; }

    /// <summary>
    ///     Gets the execution order of this component relative to the other components that
    ///     <seealso cref="SnowflakeGenerator" /> use. If all components have the default order,
    ///     which is 0, they are executed in the order they'll be placed on a snowflake.
    /// </summary>
    /// <remarks>
    ///     Note that this value does not control where the value of each component goes in the
    ///     generated snowflake. It only controls the order each component will be executed.
    ///     So that related components (like a sequence component that needs to read the last value
    ///     produced by a timestamp component) are executed in the correct order.
    /// </remarks>
    public int ExecutionOrder { get; init; }

    /// <summary>Gets or sets the snowflake generator that owns this component.</summary>
    /// <exception cref="ArgumentNullException">Value is null.</exception>
    /// <exception cref="InvalidOperationException">Component already has an owner.</exception>
    internal SnowflakeGenerator? Owner
    {
        get => _owner;
        set
        {
            ArgumentNullException.ThrowIfNull(value);

            var original = Interlocked.CompareExchange(ref _owner, value, null);
            if (original is not null && original != value)
                throw new InvalidOperationException("A snowflake component cannot be used by multiple generators.");
        }
    }

    /// <summary>Produces the value that will be placed in a snowflake.</summary>
    /// <param name="ctx">
    ///     Provides information about the current operation and the
    ///     <see cref="SnowflakeGenerator" /> instance executing it.
    /// </param>
    /// <returns>
    ///     The value generated by this component, masked to have only the lowest
    ///     <see cref="LengthInBits" /> number of bits set.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    ///     <paramref name="ctx" /> is null.
    /// </exception>
    public long GetValue(SnowflakeGenerationContext ctx)
    {
        ArgumentNullException.ThrowIfNull(ctx);

        var value = CalculateValue(ctx) & _mask;

        LastValue = value;

        return value;
    }

    /// <summary>
    ///     When overridden in a derived class, produces the original value that will be masked,
    ///     saved, and placed in a snowflake.
    /// </summary>
    /// <param name="ctx"><inheritdoc cref="GetValue" path="/param[@name='ctx']" /></param>
    /// <returns>
    ///     The original value generated by this component. It can include more than
    ///     <see cref="LengthInBits" /> number of bits set, which will be ignored by
    ///     the caller.
    /// </returns>
    /// <remarks>
    ///     This method is called by <see cref="GetValue" />, which masks it to have only the lowest
    ///     <see cref="LengthInBits" /> number of bits set, and updates <see cref="LastValue" />
    ///     with it.
    /// </remarks>
    protected abstract long CalculateValue(SnowflakeGenerationContext ctx);
}
